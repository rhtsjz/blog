# 修复Java内存模型，第1部分
什么是Java内存模型，它是如何被打破的？

## 什么是内存模型，为什么需要它？
内存模型描述了程序中变量（实例字段，静态字段，数组元素）
与在真实的计算机系统中存储它们到内存并从内存中检索它们的底层细节两者的关系。
对象最终存储在内存中，但编译器，运行时，处理器或高速缓存可能会调整数值移入或移出变量分配的内存位置的时间。
例如，编译器可以选择通过将循环索引变量存储在寄存器中来优化它，或者高速缓存可能会延迟刷新变量的一个新值到主存储器，直到更合适的时间。
所有这些优化都有助于提高性能，并且对用户而言通常都是透明的，但在多处理器系统中，这些复杂性有时可能会显现出来。

对于JMM除非程序人员使用`synchronized`或`volatile`关键字明确要求某些可见性保证，
否则它允许编译器和高速缓存对数据在特定于处理器的高速缓存（或寄存器）和主内存之间的移动顺序具有重大的自由。
这意味着在没有同步的情况下，从不同线程的角度来看，内存操作可能会以不同的顺序发生。

## 原始JMM的缺点

## JSR 133的目标

## 同步和可见性
## 问题1 不可变的对象不是不可变
## 问题2 重新排序易失性和非易失性的存储
## 总结

# 修复Java内存模型，第2部分
JMM如何根据JSR 133进行更改？
## 可见性，重新审视
## `volatile` 新的保证
尽管 `volatile` 变量的读取和写入操作无法与其他 `volatile` 变量的读取和写入进行重新排序，
但它们仍然可以与读取和写入非 `volatile` 变量进行重新排序。
## 什么发生在什么之前？
### 数据竞赛
### 这是否解决了双重检查锁定问题？
